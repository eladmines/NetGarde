name: Build and Deploy Backend

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: netgarde-backend
  ECR_REGISTRY: 804012660077.dkr.ecr.us-east-1.amazonaws.com
  RDS_INSTANCE_ID: ${{ secrets.RDS_INSTANCE_ID || 'netgarde' }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      id-token: write   # Required for OIDC authentication
      contents: read    # Required for checking out code
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Run tests
        working-directory: ./backend
        env:
          DB_URL: "sqlite:///:memory:"
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-dev.txt
          pytest --cov=app --cov-report=xml --cov-report=term

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        if: github.ref == 'refs/heads/main'  # Only push to ECR for production (main branch)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --target production \
            -f backend/Dockerfile ./backend
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Deploy to EC2
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            echo "Checking deployment directory..."
            if [ ! -d ~/netgarde ]; then
              echo "Directory ~/netgarde does not exist. Creating it..."
              mkdir -p ~/netgarde
            fi
            cd ~/netgarde || { echo "Failed to change to ~/netgarde directory"; exit 1; }
            echo "Current directory: $(pwd)"
            
            # Check and fix DNS resolution
            echo "Checking DNS resolution for github.com..."
            if ! nslookup github.com > /dev/null 2>&1; then
              echo "DNS resolution failed. Fixing DNS configuration..."
              if ! grep -q "8.8.8.8" /etc/resolv.conf; then
                echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf
                echo "nameserver 8.8.4.4" | sudo tee -a /etc/resolv.conf
              fi
              sleep 2
              if ! nslookup github.com > /dev/null 2>&1; then
                echo "ERROR: Cannot resolve github.com after DNS fix."
                exit 1
              fi
            else
              echo "DNS resolution OK"
            fi
            
            # Pull latest code
            echo "Pulling latest code from ${{ github.ref_name }} branch..."
            if [ -d .git ]; then
              git remote set-url origin https://github.com/${{ github.repository }}.git
              git fetch origin || exit 1
              # Clean untracked files and directories that might conflict
              git clean -fd || true
              # Reset any local changes
              git reset --hard HEAD || true
              # Checkout the branch (force if needed)
              git checkout ${{ github.ref_name }} || git checkout -b ${{ github.ref_name }} origin/${{ github.ref_name }}
              # Pull latest changes
              git pull origin ${{ github.ref_name }} || git reset --hard origin/${{ github.ref_name }}
            else
              echo "Git repository not found. Cloning..."
              git clone -b ${{ github.ref_name }} https://github.com/${{ github.repository }}.git .
            fi
            echo "Code updated successfully!"
            
            # Fetch RDS credentials from AWS Secrets Manager
            echo "Fetching RDS credentials from AWS Secrets Manager..."
            
            # Use RDS instance ID from environment variable or default to 'netgarde'
            DB_INSTANCE_ID="${RDS_INSTANCE_ID:-netgarde}"
            echo "Using RDS instance identifier: $DB_INSTANCE_ID"
            
            # Verify AWS CLI is configured
            echo "Checking AWS CLI configuration..."
            if ! aws sts get-caller-identity > /dev/null 2>&1; then
              echo "ERROR: AWS CLI is not configured or credentials are invalid"
              echo "The EC2 instance needs an IAM role with appropriate permissions."
              exit 1
            fi
            AWS_ACCOUNT=$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo "Unknown")
            echo "AWS Account: $AWS_ACCOUNT"
            
            # Get the secret ARN and instance status
            echo "Describing RDS instance: $DB_INSTANCE_ID"
            
            # First check if we can describe the instance
            RDS_DESCRIBE_OUTPUT=$(aws rds describe-db-instances --db-instance-identifier "$DB_INSTANCE_ID" --region us-east-1 2>&1)
            RDS_DESCRIBE_EXIT_CODE=$?
            
            if [ $RDS_DESCRIBE_EXIT_CODE -ne 0 ]; then
              echo "ERROR: Failed to describe RDS instance '$DB_INSTANCE_ID'"
              echo "AWS CLI error output:"
              echo "$RDS_DESCRIBE_OUTPUT"
              echo ""
              echo "Possible issues:"
              if echo "$RDS_DESCRIBE_OUTPUT" | grep -q "DBInstanceNotFound"; then
                echo "  1. RDS instance '$DB_INSTANCE_ID' does not exist in region us-east-1"
                echo "     - Verify the identifier is correct in RDS Console"
                echo "     - Check if the instance is in a different region"
              elif echo "$RDS_DESCRIBE_OUTPUT" | grep -q "AccessDenied\|UnauthorizedOperation"; then
                echo "  1. IAM permissions issue: EC2 instance role needs 'rds:DescribeDBInstances' permission"
                echo "     - Go to IAM Console > Roles > [Your EC2 instance role]"
                echo "     - Attach policy: AmazonRDSReadOnlyAccess"
                echo "     - Or create custom policy with: rds:DescribeDBInstances"
              else
                echo "  1. Unknown error - see AWS CLI output above"
              fi
              echo ""
              echo "  2. Verify the RDS instance identifier is correct (you said it's 'netgarde')"
              echo "  3. Verify the region is correct (currently checking us-east-1)"
              echo ""
              echo "To fix IAM permissions:"
              echo "  - IAM Console > Roles > [EC2 instance role] > Add permissions > Attach policies"
              echo "  - Search for: AmazonRDSReadOnlyAccess"
              exit 1
            fi
            
            SECRET_ARN=$(aws rds describe-db-instances \
              --db-instance-identifier "$DB_INSTANCE_ID" \
              --region us-east-1 \
              --query 'DBInstances[0].MasterUserSecret.SecretArn' \
              --output text 2>/dev/null || echo "None")
            
            DB_STATUS=$(aws rds describe-db-instances \
              --db-instance-identifier "$DB_INSTANCE_ID" \
              --region us-east-1 \
              --query 'DBInstances[0].DBInstanceStatus' \
              --output text 2>/dev/null || echo "Unknown")
            
            echo "RDS instance status: $DB_STATUS"
            
            if [ -z "$SECRET_ARN" ] || [ "$SECRET_ARN" == "None" ]; then
              echo "ERROR: RDS instance '$DB_INSTANCE_ID' does not have a master user secret in Secrets Manager!"
              echo ""
              echo "Troubleshooting steps:"
              echo "1. Check RDS instance status (should be 'available', not 'modifying'):"
              echo "   Current status: $DB_STATUS"
              echo ""
              echo "2. Verify Secrets Manager is enabled in RDS console:"
              echo "   - Go to RDS Console > Databases > $DB_INSTANCE_ID"
              echo "   - Click 'Modify'"
              echo "   - Scroll to 'Database authentication' section"
              echo "   - Check 'Manage master credentials in AWS Secrets Manager'"
              echo "   - Click 'Continue' and 'Modify DB instance'"
              echo ""
              echo "3. Wait for modification to complete (can take 5-10 minutes)"
              echo "   Status will change from 'modifying' to 'available'"
              echo ""
              echo "4. After modification completes, the secret will be automatically created"
              exit 1
            fi
            
            echo "Found secret ARN: $SECRET_ARN"
            
            # Get RDS endpoint from instance description (in case it's not in the secret)
            echo "Getting RDS endpoint..."
            DB_HOST=$(aws rds describe-db-instances \
              --db-instance-identifier "$DB_INSTANCE_ID" \
              --region us-east-1 \
              --query 'DBInstances[0].Endpoint.Address' \
              --output text 2>/dev/null || echo "")
            
            if [ -z "$DB_HOST" ]; then
              echo "ERROR: Failed to get RDS endpoint from instance description"
              exit 1
            fi
            
            DB_PORT=$(aws rds describe-db-instances \
              --db-instance-identifier "$DB_INSTANCE_ID" \
              --region us-east-1 \
              --query 'DBInstances[0].Endpoint.Port' \
              --output text 2>/dev/null || echo "5432")
            
            echo "RDS endpoint: $DB_HOST:$DB_PORT"
            
            # Retrieve the secret value
            echo "Retrieving secret from Secrets Manager..."
            SECRET_JSON=$(aws secretsmanager get-secret-value \
              --secret-id "$SECRET_ARN" \
              --region us-east-1 \
              --query SecretString \
              --output text)
            
            if [ -z "$SECRET_JSON" ]; then
              echo "ERROR: Failed to retrieve secret from Secrets Manager!"
              echo "Please check IAM permissions for the EC2 instance role."
              exit 1
            fi
            
            # Parse JSON to extract connection details using Python
            echo "Parsing secret JSON..."
            echo "Secret JSON preview (first 100 chars): $(echo "$SECRET_JSON" | head -c 100)..."
            
            # Parse JSON with better error handling - try to get each field with fallbacks
            DB_USER=$(echo "$SECRET_JSON" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('username') or d.get('user') or '')" 2>&1)
            if [ $? -ne 0 ] || [ -z "$DB_USER" ]; then
              echo "ERROR: Failed to extract username from secret JSON"
              echo "Error: $DB_USER"
              echo "Secret JSON keys: $(echo "$SECRET_JSON" | python3 -c "import sys, json; print(list(json.load(sys.stdin).keys()))" 2>&1)"
              echo "Secret JSON (first 500 chars): $(echo "$SECRET_JSON" | head -c 500)"
              exit 1
            fi
            
            DB_PASSWORD=$(echo "$SECRET_JSON" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('password') or d.get('pass') or '')" 2>&1)
            if [ $? -ne 0 ] || [ -z "$DB_PASSWORD" ]; then
              echo "ERROR: Failed to extract password from secret JSON"
              echo "Error: $DB_PASSWORD"
              exit 1
            fi
            
            # Try to get host from secret, but use RDS endpoint if not found
            DB_HOST_FROM_SECRET=$(echo "$SECRET_JSON" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('host') or d.get('endpoint') or d.get('address') or '')" 2>&1)
            if [ $? -eq 0 ] && [ -n "$DB_HOST_FROM_SECRET" ]; then
              echo "Using host from secret: $DB_HOST_FROM_SECRET"
              DB_HOST="$DB_HOST_FROM_SECRET"
            else
              echo "Host not found in secret, using RDS endpoint: $DB_HOST"
            fi
            
            # Try to get port from secret, but use RDS port if not found
            DB_PORT_FROM_SECRET=$(echo "$SECRET_JSON" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('port') or '')" 2>&1)
            if [ $? -eq 0 ] && [ -n "$DB_PORT_FROM_SECRET" ]; then
              echo "Using port from secret: $DB_PORT_FROM_SECRET"
              DB_PORT="$DB_PORT_FROM_SECRET"
            else
              echo "Port not found in secret, using RDS port: $DB_PORT"
            fi
            
            DB_NAME=$(echo "$SECRET_JSON" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('dbname') or d.get('database') or d.get('db') or d.get('dbInstanceIdentifier') or 'postgres')" 2>&1 || echo "postgres")
            
            echo "Successfully parsed secret JSON"
            echo "  Username: $DB_USER"
            echo "  Host: $DB_HOST"
            echo "  Port: $DB_PORT"
            echo "  Database: $DB_NAME"
            
            # Build DB_URL connection string (URL encode password to handle special characters)
            DB_PASSWORD_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$DB_PASSWORD'))")
            DB_URL="postgresql+psycopg2://${DB_USER}:${DB_PASSWORD_ENCODED}@${DB_HOST}:${DB_PORT}/${DB_NAME:-postgres}"
            
            # Escape % characters for ConfigParser (used by Alembic) - % needs to be %% for ConfigParser
            DB_URL_ESCAPED=$(echo "$DB_URL" | sed 's/%/%%/g')
            
            echo "Successfully retrieved RDS credentials from Secrets Manager"
            echo "Database host: $DB_HOST"
            echo "Database name: ${DB_NAME:-postgres}"
            
            # Create .env.production with the credentials (use escaped version for Alembic)
            mkdir -p backend
            echo "DB_URL=$DB_URL_ESCAPED" > backend/.env.production
            echo "PYTHONUNBUFFERED=1" >> backend/.env.production
            echo "Created backend/.env.production with credentials from Secrets Manager"
            
            # Export both versions - use escaped for Alembic, original for docker compose
            export DB_URL="$DB_URL"
            export DB_URL_ESCAPED="$DB_URL_ESCAPED"
            
            # Handle image source based on branch
            if [ "${{ github.ref_name }}" == "main" ]; then
              # Production: Pull from ECR (image was just pushed)
              echo "Production deployment: Pulling image from ECR..."
              aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
              docker compose -f docker-compose.yml pull backend || echo "Warning: Failed to pull from ECR, will build locally"
            else
              # Development: Build locally (no ECR push for develop branch)
              echo "Development deployment: Building image locally..."
              docker compose -f docker-compose.yml build backend || echo "Warning: Backend build failed"
            fi
            
            # Build dns-sync (since it's not in ECR, it needs to be built locally)
            echo "Building dns-sync container..."
            docker compose -f docker-compose.yml build dns-sync || echo "Warning: dns-sync build failed, but continuing..."
            
            # Run migrations with DB_URL_ESCAPED explicitly passed to the container (for Alembic ConfigParser)
            echo "Running database migrations..."
            docker compose -f docker-compose.yml run --rm -e DB_URL="$DB_URL_ESCAPED" backend alembic upgrade head
            
            # Start all services and remove orphaned containers (like old postgres containers)
            echo "Starting services..."
            docker compose -f docker-compose.yml up -d --remove-orphans
            
            # Show status
            echo "Service status:"
            docker compose -f docker-compose.yml ps 

            